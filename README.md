# ARH REST API (a8i) - Advanced Request Handling REST API

`ARH API` (далее `a8i`) — Легковесный протокол для выполнения множественных API-запросов за один HTTP-вызов, работающий на базе `REST API`.

Идеально подходит для веб-клиентов, где важно минимизировать количество запросов к серверу.

Получайте данные с нескольких маршрутов за один запрос, сохраняя все преимущества `REST API`.


## Содержание
- [Принцип работы](#Принцип-работы)
- [Преимущества](#Преимущества)
- [Сравнение решений](#Сравнение-решений)
- [Спецификация](#Спецификация)
- [Вопросы](#Вопросы)
- [Лицензия](#Лицензия)


# Принцип работы

1. **Клиент** формирует инструкции для подзапросов.
2. **Клиент** кодирует их в `base64url` и добавляет к основному маршруту в виде параметра `?arc=<base64url>`.

Вместо двух раздельных запросов:
```http
GET /user/1
GET /comments?user=1&limit=5
```
Один запрос:
```http
GET /user/1?arc=<json_base64url>
```
```javascript
let arc = {
  "requests": [
    {
      "name": "comments",
      "path": "/comments?user=1&limit=5"
    }
  ]
};
let arc64 = base64url(JSON.stringify(arc));
// Добавляем подзапрос к основному запросу
fetch(`/user/1?arc=${arc}`);
````

3. **Сервер** декодирует `arc` параметр, выполняет внутренние запросы.
4. **Сервер** возвращает ответ с данными основного запроса + результаты подзапросов в отдельной `ars` секции.

```json
{
  "status": {
    "code": 200,
    "message": null
  },
  "data": {
    "id": 1,
    "email": "name@example.com"
  },
  "ars": {
    "comments": {
      "status": {
        "code": 200,
        "message": null
      },
      "collection": [
        {
          "data": {
            "id": 123,
            "text": "Первый"
          }
        },
        {
          "data": {
            "id": 124,
            "text": "Второй"
          }
        }
      ]
    }
  }
}
```


# Преимущества
#### ✅ Решает проблему N+1 запрос, позволяя получить все данные за 1 запрос.
#### ✅ Сохраняет все преимущества `REST API` (кэшируемость, простота, предсказуемость).
#### ✅ Легко встраивается в текущие `REST API` проекты по мере надобности, без внесения серьёзных правок.
#### ✅ Поддерживает гибкие правила настройки ответа.
#### ✅ Обратная совместимость - старые клиенты работают без изменений.
#### ✅ Не требует сторонних библиотек.
#### ✅ Простота и производительность.


# Сравнение решений

| Требование         | A8I                       | REST API       | JSON:API                | GraphQL                          |
|--------------------|---------------------------|----------------|-------------------------|----------------------------------|
| Внедрение          | ✅ Простое                 | ✅ Нативное     | ❌ Сложное               | ❌ Сложное                        |
| N+1 проблема       | ✅ Решается                | ❌ Не решается  | ✅ Решается              | ✅ Решается                       |
| Гибкость           | ✅ Гибкая                  | ❌ Ограниченная | ✅❌ Избыточный синтаксис | ✅ Гибкая                         |
| Кэширование        | ✅ Нативное                | ✅ Нативное     | ✅ Нативное              | ❌ Нет                            |
| Производительность | ✅ Быстрая                 | ✅ Нативная     | ❌ Медленная             | ❌ Медленная                      |
| Нативность         | ✅ Нативная                | ✅ Нативная     | ❌ Сторонние библиотеки  | ❌ Сторонние библиотеки           |
| Отладка            | ✅❌ Простая с a8i-devtools | ✅ Нативная     | ✅❌ Сложный синтаксис    | ✅❌ Да в devtools, но нет в логах |

### Логический поток от проблемы к решению

+ Требуется передавать дополнительные параметры запроса.
+ + `HTTP` запрос содержит тело запроса, заголовки и сам маршрут. ↓
+ + Передача параметров в теле `GET` запроса не позволит кэшировать запрос с учётом параметров, а в логах отобразится только маршрут без параметра. ❌ `Отклонено`↓
+ + Передача параметров в заголовке потребует изменить формат логов и функционал кэширования (учёт заголовка). ❌ `Отклонено`↓
+ + Передача параметров в маршруте не потребует изменений и более предсказуема. ✅ `Решено`.
+ Требуется выбрать формат параметров. ↓
+ + Есть нативный `json`, есть более быстрый и компактный `msgpack`. ↓
+ + Оба URL-недружелюбные. Требуется кодирование в `base64url` или другие подходящее форматы. ↓
+ + Можно по умолчанию использовать нативный `json`, а по желанию любой другой формат. ✅ `Решено`.
+ Требуется принятое название параметра для `base64url` контейнера, содержащего `json` набор инструкций. ↓
+ + Если `a8i` - это `Advanced Request Handling`, то контейнер это `Advanced Request Container` (`&arc=`). ✅ `Решено`.
+ Требуется секция в данных ответа на запрос, содержащая ответ вложенных запросов. ↓
+ + Если `arc` - это контейнер запроса, то секция для ответа это `Advanced Response Section` (`ars`). ✅ `Решено`.
+ Требуется дать возможность вместо `base64url` использовать другое кодирование. ↓
+ Требуется заложить возможность выбора формата данных в контейнере `arc`. ↓
+ + Если формат по умолчанию `json`, но потребовалось использовать более компактный `msgpack` или строгий `protobuf`, то нужно дать возможность указать формат данных в параметре `arc`. ↓
+ + Использовать отдельный параметр `arc_format`. Избыточно. ❌ `Отклонено`↓
+ + Зашить формат внутри `base64url`. Непонятно пока не распакуешь, `base64url` по умолчанию, но не единственный. ❌ `Отклонено`↓
+ + Добавляем название формата после точки `&arc=anNvbmZvcm1hdA.json64u`, `&arc=bXNncGFja2Y.msgpack64u`. ✅ `Решено`.


# Спецификация

## Основные понятия

### 1. ARH (Advanced Request Handler)
Серверный обработчик, который:
- Принимает запросы с параметром `arc`
- Выполняет инструкции
- Добавляет секцию `ars` к ответу

```php
public function arh(Request $request, Response $response): Response
```
### 2. ARC (Advanced Request Container)
Бинарный контейнер инструкций:
- Формат: MessagePack + Base64URL
- Содержит:
  - requests - массив подзапросов
  - options - дополнительные правила

### 3. ARS (Advanced Response Section)
Секция с результатами подзапросов:
- Ключи: `name` из `arc` или автоматически сгенерированные

### Структура ARC
```json
{
  "requests": [
    {
      "name": "string",      // идентификатор запроса и ответа (опционально, по умолчанию md5hash от path)
      "path": "string",      // относительный URL маршрута (опционально, если name это предустановленный маршрут)
      "method": "GET",       // опционально (по умолчанию GET)
      "parameters": {},      // опционально
      "headers": {},         // опционально
      "body": {}             // опционально
    }
  ],
  "options": {
    "strip_null": true,      // удалять null поля
    "timeout": 5000          // таймаут в ms
  }
}
```

### Форматы данных
+ По умолчанию: `JSON + base64url`.
+ Поддерживается: `MessagePack`, `Protobuf` и другие.
+ Указание формата: `?arc=<json_base64url>.json64u` или `?arc=<msgpack_base64url>.msgpack64u`.


# Вопросы

### Почему по умолчанию не MessagePack?
Да, на больших данных `msgpack` показывает на ~25% лучшую скорость и на ~25% меньший размер. \
Да, `msgpack` не требует схем как `protobuf` или `avro`. \
Но `msgpack` не поддерживается в языках программирования нативно, нужно ставить расширение или библиотеку. \
А в реальных проектах, где `arc` содержит 1 - 2 инструкции разницы мало. Вот пример на 10 миллионах итераций преобразования 2 таких инструкций на `php`:
```php
$arc = [
    'requests' => array_fill(0, 2, [
        'name' => 'news',
        'path' => '/v1/news?rubrics=1,2,3&statuses=published&limit=50'
    ]),
    'options' => [
        'strip_null' => true
    ]
];
while (true) {
    if ($i++ > 10000000) {
        break;
    }
    base64UrlEncode(json_encode($arc, JSON_UNESCAPED_UNICODE));
    // base64UrlEncode(msgpack_pack($arc))
}
```
`json_encode` - длинна base64Url 267, время 9 секунд. \
`msgpack_pack` - длинна base64Url 224, время 8 секунд. \
Для большинства проектов это незначительная разница и не нужно устанавливать `msgpack`. \
Для проектов, чувствительных к размеру данных `a8i` поддерживает любые другие форматы.

### Почему название `a8i`?

`a8i` — Нумероним `A<8 символов>I` от `ARH REST API` (Advanced Request Handler REST API)

| Короткое имя | Полное имя                         |
|--------------|------------------------------------|
| a8i          | ARH API                            |
| ARH API      | Advanced Request Handling REST API |


### Чем это лучше GraphQL?
+ `a8i` сохраняет преимущества `REST`
+ проще внедряется
+ не требует карт сопоставления
+ не требует библиотек
+ быстрее работает (проще парсинг)

### Чем это лучше JSON:API?
+ `a8i` проще внедряется 
+ быстрее работает (проще парсинг)
+ не требует карт сопоставления
+ не требует библиотек
+ URL-дружелюбный в отличие от `?include=news,comments&filter%5Bnews%5D%5Brubrics%5D=1,2,3&filter%5Bnews%5D%5Bstatuses%5D=published&filter%5Bnews%5D%5Blimit%5D=50&filter%5Bcomments%5D%5Brubrics%5D=1,2,3&filter%5Bcomments%5D%5Bstatuses%5D=published&filter%5Bcomments%5D%5Blimit%5D=50&fields%5Bnews%5D=title,content,created_at&fields%5Bcomments%5D=text,author,created_at`.

### Нужно ли переписывать существующие API?
Нет. `a8i` использует ваши существующие `REST` маршруты. Потребуется только обработчик `arc` параметра.

### В логах base64 непонятен, как анализировать?
Простой способ как для `a8i`, так и для `GraphQL` и `JSON:API` это добавить `meta` параметр с ключевыми для аналитики данными. \
Например: `/user/1?arc=eyJyZXF1ZXN0cyI6W3s&meta=news:pub` для подзапроса опубликованных новостей.

### Есть ли ограничения?
Браузеры по-разному ограничивают длину маршрута, размер заголовков, количество запросов и т.д. \
Устаревшие браузеры поддерживают длину порядка 2000 символов, современные 32000 и даже 64000 и больше. \
Если поддерживать совместимость со старыми браузерами и брать максимальную длину в 2000 символов, то это порядка 20 вот таких `json` инструкций:
```php
{
    "name": "news",
    "path": "/v1/news?rubrics=1,2,3&statuses=published&limit=50"
}
```
Или 22 `msgpack`. \
На современных браузерах 300+ инструкций. \
В реальности вам понадобиться 1 - 4 инструкции.


# Безопасность
Рекомендуемые меры:
+ Белый список разрешённых маршрутов
+ Ограничение количества вложенных запросов
+ Ограничение уровней вложенности (рекурсия)


# Лицензия

`MIT License` — можно свободно использовать в коммерческих проектах.